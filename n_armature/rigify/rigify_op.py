import bpy
from bpy.types import Operator
import addon_utils
from mathutils import Vector


class Base_Rigify_Poll:
    @classmethod
    def poll(cls, context):
        # https://blender.stackexchange.com/questions/43703/how-to-tell-if-an-add-on-is-present-using-python
        enabled_rigify = all(addon_utils.check("rigify"))
        rig_id = context.object.data.get('rig_id')
        mode = (context.mode == 'POSE')
        if not enabled_rigify:
            cls.poll_message_set('"Rigify" addon not enabled.')
        elif not rig_id:
            cls.poll_message_set('Rigify "rig_id" property not found. Rig must be generated by rigify.')
        elif not mode:
            cls.poll_message_set("Mode must be Pose.")
        return enabled_rigify and rig_id and mode


class MXD_OT_Armature_Rigify_GenerateWrapper(Base_Rigify_Poll, Operator):
    bl_idname = "rigify.generate_wrapper"
    bl_label = ""
    bl_options = {'REGISTER', 'UNDO', 'INTERNAL'}
    bl_description = (
        "Wrapper of Rigify Generate Operator.\n\n"   
        "Changes:\n"                                 
        "    Start with FK.\n"                       
        "    IK Stretch disabled.\n"                 
        "    BBone Segments to 1.\n"                 
        '    Retain "locked" states.\n'              
        "    Retain location, rotation and scale.\n" 
        "    Retain pose position.\n"                
        "    Retain non-rigify-generated bones, constraints, and bone collections"
        )

    @classmethod
    def poll(cls, context):
        return bpy.ops.pose.rigify_generate.poll()

    def invoke(self, context, event):
        metarig = context.object
        
        if (target_rig := metarig.data.rigify_target_rig):
            # Since rigify_generate() removes post-generate new data, store them so that they ca be remade later

            pose_position = target_rig.data.pose_position
            all_bcolls = target_rig.data.collections_all

            # Bone collections
            bcoll_properties = {}
            for bcoll in all_bcolls:
                props = {}
                for prop in bcoll.bl_rna.properties:
                    if not prop.is_readonly:
                        value = getattr(bcoll, prop.identifier)
                        if prop.identifier == "parent" and value:
                            value = value.name
                        props[prop.identifier] = value

                props['locked'] = bcoll.MixedPie.locked
                if bcoll.child_number != 0:
                    # Maintain arrangement by binding it to its relative above, since if there are more collections added in metarig it could mess the order
                    siblings = bcoll.parent.children if bcoll.parent else target_rig.data.collections
                    props['collection_above'] = siblings[bcoll.child_number - 1].name

                bcoll_properties[bcoll.name] = props                

            # edit_bone properties, used to remake bones later
            context.view_layer.objects.active = target_rig
            bpy.ops.object.mode_set(mode='EDIT')
            edit_bone_properties = {}
            for bone in target_rig.data.edit_bones:
                props = {}
                for prop in bone.bl_rna.properties:
                    if not prop.is_readonly:
                        value = getattr(bone, prop.identifier)
                        if isinstance(value, Vector):
                            value = tuple(value)
                        if prop.identifier == "parent" and value:
                            value = value.name
                        props[prop.identifier] = value
                edit_bone_properties[bone.name] = props

            # Contraints
            bones_rotLocScale_constraints_props = {}
            for bone in target_rig.pose.bones:
                rotLocScale = {}
                constraints = []
                other_props = {}

                for mode in ("rotation_quaternion", "rotation_euler", "rotation_axis_angle", "location", "scale"):
                    rotLocScale[mode] = tuple(getattr(bone, mode))

                for constraint in bone.constraints:
                    props = {}
                    for prop in constraint.bl_rna.properties:
                        if not prop.is_readonly:
                            props[prop.identifier] = getattr(constraint, prop.identifier)
                    constraints.append((constraint.type, props))

                other_props['collections'] = tuple(coll.name for coll in bone.bone.collections)
                bones_rotLocScale_constraints_props[bone.name] = (rotLocScale, constraints, other_props)

        context.view_layer.objects.active = metarig
        result = bpy.ops.pose.rigify_generate()
        if result == {'FINISHED'}:
            if target_rig:
                target_rig.data.pose_position = pose_position

                # Remake missing bone collections
                for name, props in bcoll_properties.items():
                    collection_above = props.pop('collection_above', None)
                    if (parent_name := props['parent']):
                        props['parent'] = all_bcolls[parent_name]

                    if name not in all_bcolls:
                        bcoll = target_rig.data.collections.new(name)

                        for prop, value in props.items():
                            if prop == "locked":
                                bcoll.MixedPie.locked = value
                            else:
                                setattr(bcoll, prop, value)
                    else:
                        bcoll = all_bcolls[name]
                        for prop in {"is_visible", "is_solo", "is_expanded"}:
                            setattr(bcoll, prop, props[prop])

                        bcoll.MixedPie.locked = props['locked']

                    if collection_above:
                        siblings = bcoll.parent.children if bcoll.parent else target_rig.data.collections
                        bcoll.child_number = siblings[collection_above].child_number + 1

                # Remake missing bones
                if (custom_bones := [name for name in bones_rotLocScale_constraints_props if name not in target_rig.pose.bones]):
                    bpy.ops.object.mode_set(mode='EDIT')
                    edit_bones = target_rig.data.edit_bones

                    for name in custom_bones:
                        edit_bone = edit_bones.new(name)
                        for prop, value in edit_bone_properties[name].items():
                            if prop == "parent":
                                value = edit_bones[value]
                            setattr(edit_bone, prop, value)
                    bpy.ops.object.mode_set(mode='OBJECT')
                
                # Remake missing constraints
                for name, (rotLocScale, constraints, props) in bones_rotLocScale_constraints_props.items():
                    bone = target_rig.pose.bones[name]
                    for bcoll_name in props['collections']:
                        if bone.name not in (bcoll := all_bcolls[bcoll_name]).bones:
                            bcoll.assign(bone)

                    for attr, value in rotLocScale.items():
                        setattr(bone, attr, value)

                    b_constraints = bone.constraints
                    for type, constraint in constraints:
                        if not constraint:
                            continue
                        if constraint['name'] in b_constraints:  # Skip rigify-generated constraint since there may be changes
                            continue
                        new_contraint = b_constraints.new(type)
                        for prop, value in constraint.items():
                            setattr(new_contraint, prop, value)

            target_rig = target_rig or bpy.data.objects[bpy.data.armatures[-1].name]
            if target_rig:
                for p_bone in target_rig.pose.bones:
                    if p_bone.get("IK_FK") is not None:
                        p_bone["IK_FK"] = 1
                    if p_bone.get("IK_Stretch") is not None:
                        p_bone["IK_Stretch"] = 0
                    p_bone.bone.bbone_segments = 1

            metarig.hide_set(True)

        return result
        

class MXD_OT_Armature_Rigify_IK_FK(Base_Rigify_Poll, Operator):
    bl_idname = "rigify.ik_fk"
    bl_label = "IK/FK"
    bl_options = {'REGISTER', 'UNDO', 'INTERNAL'}
    bl_description = "Set rigify's bone IK/FK switch of selected pose parent bones to 1 (FK).\n\n"  \
                     "Shift: Set it to 0 (IK) instead"

    def invoke(self, context, event):
        set_property(self, context, event, 'IK_FK', (1.0, 0.0), ("FK", "IK"))
        return {'FINISHED'}


def set_property(self, context, event, prop_name, values, value_description, set=True):
    counter = 0
    for bone in context.selected_pose_bones:
        if bone.get(prop_name) is not None:
            bone[prop_name] = values[0] if not event.shift else values[1]
            counter += 1

    # Redraw if rigify panel is open since it won't sync automatically
    if context.space_data.show_region_ui:
        for region in context.area.regions:
            if region.type == 'UI':
                region.tag_redraw()

    property = "properties" if (counter > 1) else "property"
    value = value_description[0] if not event.shift else value_description[1]
    if set:
        self.report({'INFO'}, f"Set {counter} '{prop_name}' {property} to {value}")
    else:
        self.report({'INFO'}, f"{value} {counter} '{prop_name}' {property}")


class MXD_OT_Armature_Rigify_IKStretch(Base_Rigify_Poll, Operator):
    bl_idname = "rigify.ik_stretch"
    bl_label = "IK Stretch"
    bl_options = {'REGISTER', 'UNDO', 'INTERNAL'}
    bl_description = "Set rigify's bone IK stretch of selected pose parent bones to 0 (disabled).\n\n"  \
                     "Shift: Set it to 1 (enabled) instead"

    def invoke(self, context, event):
        set_property(self, context, event, 'IK_Stretch', (0.0, 1.0), ("Disabled", "Enabled"), set=False)
        return {'FINISHED'}


class MXD_OT_Armature_OneBBoneSegment(Operator):
    bl_idname = "armature.one_bbone_segment"
    bl_label = "Set B-Bone Segment to 1"
    bl_options = {'REGISTER', 'UNDO', 'INTERNAL'}
    bl_description = "Set bendy bone segment of all bones in armature to 1.\n"      \
                     "If the bone is a rigify type and part of a metarig, also set its bendy bone segment option to 1"

    def draw(self, context):
        layout = self.layout
        split = layout.split(factor=0.6)
        col1 = split.column()
        col1.alignment = 'RIGHT'
        col2 = split.column()

        if self.counter or not self.rigify_counter:
            col1.label(text="Modified Bone Properties:")
            col2.label(text=f"{self.counter}")

        if self.rigify_counter:
            col1.label(text="Modified Rigify Properties:")
            col2.label(text=f"{self.rigify_counter}")

    def execute(self, context):
        self.counter = 0
        self.rigify_counter = 0
        obj = context.object
        data = obj.data
        pose_bones = obj.pose.bones
        bones = data.bones if (context.mode == 'POSE') else data.edit_bones
        for bone in bones:
            if bone.bbone_segments != 1:
                bone.bbone_segments = 1
                self.counter += 1
            if (params := getattr(pose_bones[bone.name], "rigify_parameters", None)):
                if params.bbones != 1:
                    params.bbones = 1
                    self.rigify_counter += 1
        return {'FINISHED'}


classes = (
    MXD_OT_Armature_Rigify_GenerateWrapper,
    MXD_OT_Armature_Rigify_IK_FK,
    MXD_OT_Armature_Rigify_IKStretch,
    MXD_OT_Armature_OneBBoneSegment,
)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)


def unregister():
    for cls in classes:
        bpy.utils.unregister_class(cls)
